#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//将三个数从大到小的顺序输出

//int main()
//{
//	int a = 0;
//	int b = 0;
//	int c = 0;
//	scanf("%d%d%d", &a, &b, &c);//2 1 3             特别注意，scanf是取地址输入函数，因此，后面应该是取地址&a等等
//  scanf后面的格式窜中怎么写的，输入的时候就要怎么写。若为“a,b,c"则输入时应该为“2,1,3”。即也要带上逗号,
//	//算法实现
//	//a中放最大值
//	//b次之
//	//c中放最小值
//	if(a<b)
//	{
//		int tmp = a;//创建一个临时变量，先将a中的内容放进去
//		a = b;
//		b = tmp;
//	}
//	if(a<c)
//	{
//		int tmp = a;
//		a = c;
//		c = tmp;
//	}
//	if(b<c)
//	{
//		int tmp = b;
//		b = c;
//		c = tmp;
//	}
//
//	printf("%d %d %d\n", a, b, c);
//	return 0;
//}

// 打印1-100中3的倍数

// int main()
// {
// 	int i = 0;
// 	for(i=1; i<=100; i++)
// 	{
// 		if(i%3 == 0)
// 			printf("%d ", i);
// 	}
// 	return 0;
// }

////给两个数，求最大公约数，有个方法叫，辗转相除法

////先将两个数m n相除（默认是前面的n大，若不是则加个判断大小即可，假设m<n则，内容交换就好了），看余数是否为0，若为0，则除数是最大公约数
////否则将不为0的余数存到r中，然后将n原来的值赋值给m，然后将余数r的内容赋值给n
////如此循环往复，直至余数为0为止
//int main()
//{
//	int m = 24;
//	int n = 18;
//	int r = 1;
//	scanf("%d%d", &m ,&n);
//	while(m%n)//括号内默认判断m%n的模值为真时，执行循环
//		                    //还有一种写法是while(r!=0)或者是while(r==1)
//	                        ///*while (r != 0)*/
//	                        ///*while (r == 1)*/
//	{
//		r = m%n;//将模值送到r中去
//		m = n;//将n值赋予到m中
//		                    //if (0==r)
//		                    //	break;
//		n = r;//将模值赋予到n中
//	}
//	printf("%d\n", n);
//	return 0;
//}
//

//打印1000-2000年之间的闰年

//int main()
//{
//	int year = 0;	
//	int count = 0;
//	for(year=1000; year<=2000; year++)
//	{
//		//判断year是否为闰年
//		//1. 能被4整除并且不能被100整除是闰年
//		//2. 能被400整除是闰年
//		//if(year%4==0 && year%100!=0)
//		//{
//		//	printf("%d ", year);
//		//	count++;
//		//}
//		//else if(year%400==0)
//		//{
//		//	printf("%d ", year);
//		//	count++;
//		//}
//		if(((year%4==0)&&(year%100!=0))||(year%400==0))
//      //可以用这一条写完条件
//		{
//			printf("%d ", year);
//			count++;
//		}
//	}
//	printf("\ncount = %d\n", count);
//	return 0;
//}

//打印100-200之间的素数

//int main()
//{
//	int i = 0;
//	int count = 0;
//	for(i=100; i<=200; i++)
//	{
//		//判读i是否为素数,只能被1或本身整除
//		//素数判断的规则
//		//1. 试除法
//		//产生2到i-1的数字，即除去1及其本身以外的所有数
//		int j = 0;
//		for(j=2; j<i; j++)
//		{
//			if(i%j == 0)
//			{
//				break;
//			}
//		}
//      //break会跳到这里来
//		if(j == i)
//		{
//			count++;
//			printf("%d ", i);
//		}
//	}
//	printf("\ncount = %d\n", count);
//	return 0;
//}

//代码优化如下：
//若能写成i=a*b的形式，则a和b中至少有一个数字<=开平方i
#include <math.h>

//
//int main()
//{
//	int i = 0;
//	int count = 0;
//	//sqrt - 开平方的数学库函数
//	for(i=100; i<=200; i++)
//	{
//		//判读i是否为素数
//		//素数判断的规则
//		//1. 试除法
//		//产生2->i-1
//		int j = 0;
//		for(j=2; j<=sqrt(i); j++)//在j小于等于开平方i之间去找，节约时间
//		{
//			if(i%j == 0)//i能被整除时，即不是素数时--break
//			{
//				break;
//			}
//		}
//      //break跳到这里
//		if(j>sqrt(i))//j小于开平方i时，说明当前的i值还未判断完，j大于开平方i时，将素数+1，并且打印素数
//		{
//			count++;
//			printf("%d ", i);
//		}
//	}
//	printf("\ncount = %d\n", count);
//	return 0;
//}
//
// 
// 
// 
//int main()
//{
//	int i = 0;
//	int j = 0;
//	int count = 0;
//	//sqrt - 开平方的数学库函数
//	for(i=101; i<=200; i+=2)//偶数一定不可能是素数，因为他能被2整除，所以改变变量范围，直接在100-200之间的奇数之中去找这些素数，实际上也会节约时间
//	{
//		//判读i是否为素数
//		//素数判断的规则
//		//1. 试除法
//		//产生2->i-1
//		for(j=2; j<=sqrt(i); j++)//进入for循环
//		{//在这一步，对j赋值2       循环再次进入时j+1此时变为3
//			if(i%j == 0)//i能被整除时，即不是素数时--break
//			{
//				break;
//			}
//			//i不能被整除时，不执行break,而是到这里来，随后继续内部的for循环，再次进入for循环并令j+1=3
//		}
//		//一旦检测到一个值能被整除，而不是素数时，break就会跳到这里来，直接结束内部for循环，此时的j值是一定小于开平方i的值的--即不会执行if语句--就不会增加素数的值--也不会打印当前的i值。
//		//换句话说，当他不能被整除时--是素数时，会一直在内部for循环中执行，直到检测到它的值超出检测范围即j值大于开平方i，随后满足下面的if语句，并且素数值+1，并打印。   到此为止，检测完当前的第一个i值，并进入大的for循环中，开始执行下一次的i值
//		if(j>sqrt(i))
//		{
//			count++;
//			printf("%d ", i);
//		}
//	}
//	printf("\ncount = %d\n", count);
//	return 0;
//}
//
// <素数求解的n种境界>
// 
