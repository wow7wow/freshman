#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//将一个整形数组升序排序。

//void bubble_sort(int arr[], int sz)                          //排序就行，不需要返回值--即void
//{
//	                                                           //第一步----确定冒泡排序的趟数
//                                                             //这个趟数由元素个数决定，n个元素，要n-1趟
//	int i = 0;
//	for (i = 0; i < sz - 1; i++)                               //外面的for循环内是每一趟冒泡排序
//	{
//		int flag = 1;                                          //假设这一趟要排序的数据已经有序
//		                                                       //进入内部for循环
//		int j = 0;
//		for (j = 0; j < sz-1-i; j++)
//		{
//			if(arr[j] > arr[j + 1])                            //两两元素下标进行比较
//			{
//				int tmp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tmp;                              //两两交换，把最大的数放到最后面
//				flag = 0;                                      //当在内部for循环中有交换是，说明本趟排序的数据其实不完全有序
//			}                                                  //则将flag设置为0，即要继续冒泡排序
//		}
//		if (flag == 1)                                         //这里if执行的条件是在内部for循环执行完之后才执行的
//                                                             //即至少执行完一趟冒泡排序之后，才会进入if语句去判断整个的是否已经排序完毕
//                                                             //若整个的排序也完毕之后，则直接break退出这个函数
//                                                             //否则，则未排序完，继续外部for循环，进行第二趟的冒泡排序
//                                                             //一旦发现flag为1，则说明内部的已经完全排序完毕了
//		{
//			break;
//		}
//	}
//}
//int main()
//{
//	int arr[] = { 0,1,2,3,4,5,6,7,8,9 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	                                                           //对arr进行排序，排成升序
//	                                                           //arr是数组，我们对数组arr进行传参
//                                                             //实际上传递过去的是数组arr首元素的地址 &arr[0]
//	bubble_sort(arr, sz);//冒泡排序函数
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}


//冒泡排序
//10 9 8 7 6 5 4 3 2 1
//9 10 8 7 6 5 4 3 2 1 
//9 8 10 7 6 5 4 3 2 1
//9 8 7 10 6 5 4 3 2 1
// ……
//9 8 7 6 5 4 3 2 1 10
//当10来到最后一个时，第一次冒泡排序完毕
//每次冒泡排序最多，需要n-1次交换顺序，n是需要进行处理的数字多少
// 10个元素，要进行9  次冒泡排序
// n 个元素，要进行n-1次冒泡排序
// 第1次冒泡排序，要比较9次
// 第2次冒泡排序，要比较8次





//break 是用于中止循环或者跳出stitch语句的

//int main()
//{
//	if (1)
//		break;                                                 //err，会报错，if单独用不了break
//	return 0;
//}


//数组名就是首元素地址,有两个情况是例外

//int main()
//{
//	int arr[] = { 1, 2, 3, 4, 5, 6, 7 };
//	printf("%p\n", arr);                                       //数组名就是首元素地址
//    printf("%p\n", &arr[0]);                                   //这个打印出来的也是首元素地址，和上面的结果是一样的
//	printf("%p\n", arr+1);
//
//	printf("%p\n", &arr[0]);                                   //
//	printf("%p\n", &arr[0]+1);                                 //这里得到的结果相差1
//
//	printf("%p\n", &arr);                                      //这里得到的是数组的地址，是指的从数组第一个元素地址开始，代表整个数组的地址
//	printf("%p\n", &arr+1);                                    //这里得到的结果相差28，因为这里一个数组有7个元素，数据类型为int,占4个字节，所以字节地址相差28
//
//
//
//	//int sz = sizeof(arr) / sizeof(arr[0]);
//	//1. sizeof(数组名) - 数组名表示整个数组，sizeof(数组名)计算的是整个数组的大小，单位是字节
//	//   sizeof内部单独放一个数组名，此时数组名是整个数组
//	//2. &数组名，数组名代表整个数组，&数组名，取出的是整个数组的地址
//
//	//printf("%p\n", arr);
//	//printf("%p\n", &arr[0]);
//	//printf("%d\n", *arr);                                    //1----对首元素地址进行解引用，即打印出首元素地址内容
//	return 0;
//}